from dataclasses import dataclass
from typing import Tuple, List, Dict, Union, Set, NewType, Any

CorrectionSuggestion = NewType('CorrectionSuggestion', str)
FeatureType = NewType('FeatureType', str)
Suggestions = NewType('Suggestions', List[Dict[CorrectionSuggestion, Dict[FeatureType, Any]]])


@dataclass
class ValueSuggestions:
    """A class to hold the suggestions generated by the Value Feature-Generator."""
    cell: Tuple[int, int]
    suggestions: Suggestions
    model_types = ["identity_remover",
                   "unicode_remover",
                   "identity_adder",
                   "unicode_adder",
                   "identity_replacer",
                   "unicode_replacer",
                   "identity_swapper",
                   "unicode_swapper"]

    @property
    def identity_suggestions(self) -> List[Dict[str, Suggestions]]:
        return [self.suggestions[0], self.suggestions[2], self.suggestions[4], self.suggestions[6]]

    @property
    def n_identity_suggestions(self) -> int:
        return sum([len(suggestions) for suggestions in self.identity_suggestions])

    @property
    def unicode_suggestions(self) -> List[Dict[str, Suggestions]]:
        return [self.suggestions[1], self.suggestions[3], self.suggestions[5], self.suggestions[7]]

    @property
    def n_unicode_suggestions(self) -> int:
        return sum([len(suggestions) for suggestions in self.unicode_suggestions])

    @property
    def unique_identity_suggestions(self) -> Set[str]:
        return {s for suggestion in self.identity_suggestions for s in suggestion.keys()}

    @property
    def unique_unicode_suggestions(self) -> Set[str]:
        return {s for suggestion in self.unicode_suggestions for s in suggestion.keys()}

    def certain_model_type_indices_and_suggestions(self, feature: str) -> Tuple[List[int], List[str]]:
        """Index of model types that make a certain suggestion."""
        indices = []
        certain_suggestions = []
        for i, model_suggestions in enumerate(self.suggestions):
            for suggestion, features in model_suggestions.items():
                if features[feature] == 1:
                    indices.append(i)
                    certain_suggestions.append(suggestion)
        return indices, certain_suggestions

    def n_certain_suggestions(self, feature: str) -> int:
        """Number of suggestions with probability 1.0"""
        return sum([1 for model_suggestions in self.suggestions for features in model_suggestions.values() if features[feature] == 1])

    def get_certain_suggestions(self, feature: str) -> List:
        """Return all certain suggestions."""
        return [s for model_suggestions in self.suggestions for s, features in model_suggestions.items() if features[feature] == 1]

    def n_certain_unicode_suggestions(self, feature: str) -> int:
        """Number of unicode suggestions with probability 1.0"""
        return sum([1 for model_suggestions in self.unicode_suggestions for features in model_suggestions.values() if features[feature] == 1])

    def n_certain_identity_suggestions(self, feature: str) -> int:
        """Number of identity suggestions with probability 1.0"""
        return sum([1 for model_suggestions in self.identity_suggestions for features in model_suggestions.values() if features[feature] == 1])

    def rule_based_suggestion_v1(self, d) -> Union[str, None]:
        """
        Cleaning heuristic to determine the best rule-based suggestion. Documentation on this can be found in
        the experiment from 2022W38.
        """
        if self.n_certain_suggestions('encoded_string_frequency') == 0:  # No certain suggestion at all.
            return None

        if self.n_certain_suggestions('encoded_string_frequency') == 1:  # Use the one certain suggestion.
            choice = [suggestion for model_suggestions in self.suggestions for suggestion, features in model_suggestions.items() if features['encoded_string_frequency'] == 1]
            if len(choice) > 1:
                raise ValueError(f"More than one certain suggestion: {choice}")
            choice = choice[0]

        elif self.n_certain_unicode_suggestions('encoded_string_frequency') == 1:  # Use the one certain unicode-encoded suggestion.
            # Das funktioniert in der Praxis nicht perfekt. Ich bekomme auf rayyan z.B. "1/13" als Vorschlag, obwohl ich
            # einen datestring %m/%d/%y erwarte.
            choice = [suggestion for model_suggestions in self.unicode_suggestions for suggestion, features in model_suggestions.items()
                      if features['encoded_string_frequency'] == 1]
            if len(choice) > 1:
                raise ValueError(f"More than one certain suggestion: {choice}")
            choice = choice[0]

        else:  # sum up the probabilities of both encodings of all certain corrections and take the max.
            suggestion_sums = {}
            indices, suggestions = self.certain_model_type_indices_and_suggestions('encoded_string_frequency')
            for i, s in zip(indices, suggestions):
                if i % 2 == 0:
                    corresponding_index = i + 1
                else:
                    corresponding_index = i - 1
                corresponding_features = self.suggestions[corresponding_index].get(s, {})
                corresponding_score = corresponding_features.get('encoded_string_frequency', 0)
                if suggestion_sums.get(s) is None:
                    suggestion_sums[s] = self.suggestions[i][s]['encoded_string_frequency'] + corresponding_score
                else:
                    suggestion_sums[s] += self.suggestions[i][s]['encoded_string_frequency'] + corresponding_score
            choice = max(suggestion_sums, key=suggestion_sums.get)
        return choice

    def rule_based_suggestion_v3(self, d) -> Union[str, None]:
        choice = None
        if self.n_certain_suggestions('encoded_string_frequency') == 0:  # No certain suggestion at all.
            return choice

        if self.n_certain_suggestions('encoded_string_frequency') == 1:  # Use the one certain suggestion.
            choice = [suggestion for model_suggestions in self.suggestions for suggestion, features in model_suggestions.items() if features['encoded_string_frequency'] == 1]
            if len(choice) > 1:
                raise ValueError(f"More than one certain suggestion: {choice}")
            choice = choice[0]

        elif self.n_certain_unicode_suggestions('encoded_string_frequency') == 1:  #  Use the one certain unicode-encoded suggestion.
            # Das funktioniert in der Praxis nicht perfekt. Ich bekomme auf rayyan z.B. "1/13" als Vorschlag, obwohl ich
            # einen datestring %m/%d/%y erwarte.
            choice = [suggestion for model_suggestions in self.unicode_suggestions for suggestion, features in model_suggestions.items() if features['encoded_string_frequency'] == 1]
            if len(choice) > 1:
                raise ValueError(f"More than one certain suggestion: {choice}")
            choice = choice[0]
        return choice
