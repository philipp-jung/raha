import numpy as np
import pandas as pd
from dataclasses import dataclass
from typing import Tuple, List, Dict, Union, Set
from Levenshtein import distance as levenshtein_distance


def lev_to_original_error(error_cell: Tuple[int, int],
                          old_error_cells: List[Tuple[int, int]],
                          df_dirty: pd.DataFrame) -> List[float]:
    """
    Bei mehreren unicode-encodeten Suggestions müssen wir eine Suggestion auswählen. Unser Maß hierzu ist
    lev(ursprünglicher Fehler, Fehler aus dem die Regel erstellt wurde). Allgemein gibt es mehrere Fehler, aus denen
    die Regel stammt.
    @param error_cell: Coordinates of the error currently being corrected.
    @param old_error_cells: List of Coordinates of the errors whose corrections were used to create the correcting rule.
    @param df_dirty: Table that is being cleaned.
    @return: Mean levenshtein distance between the error being corrected and the errors used to create the correcting
    rule.
    """
    distances = []
    error_value = df_dirty.iloc[error_cell]
    for old_error_cell in old_error_cells:
        old_error_value = df_dirty.iloc[old_error_cell]
        distances.append(levenshtein_distance(error_value, old_error_value))
    return distances


def lev_to_original_corrections(correction_suggestion: str,
                                old_error_cells: List[Tuple[int, int]],
                                labeled_cells: Dict[Tuple[int, int], List]) -> List[float]:
    """
    Wenn lev_to_original_error keine minimale Distanz birgt, berechnen wir die Levenshtein-Distanz zwischen der ur-
    sprünglichen Korrektur, der zur Operation geführt hat, und dem Korrekturvorschlag.
    @param correction_suggestion: Suggestion to correct the current error
    @param old_error_cells: List of Coordinates of the errors whose corrections were used to create the correcting rule
    @param labeled_cells: Dictionary containing user input
    @return: List of levenshtein distances.
    """
    distances = []
    old_corrections = [labeled_cells[cell][1] for cell in old_error_cells]
    for old_correction in old_corrections:
        distances.append(levenshtein_distance(correction_suggestion, old_correction))
    return distances


@dataclass
class ValueSuggestionsV1:
    """A class to hold the suggestions generated by the Value Feature-Generator."""
    cell: Tuple[int, int]
    suggestions: List[Dict[str, float]]
    model_types = ["identity_remover",
                   "unicode_remover",
                   "identity_adder",
                   "unicode_adder",
                   "identity_replacer",
                   "unicode_replacer",
                   "identity_swapper",
                   "unicode_swapper"]

    @property
    def all_suggestions(self):
        return [suggestion for model in self.suggestions for suggestion in model]

    @property
    def identity_suggestions(self) -> List[Dict[str, float]]:
        return [self.suggestions[0], self.suggestions[2], self.suggestions[4], self.suggestions[6]]

    @property
    def unicode_suggestions(self) -> List[Dict[str, float]]:
        return [self.suggestions[1], self.suggestions[3], self.suggestions[5], self.suggestions[7]]

    @property
    def certain_model_type_indices_and_suggestions(self) -> Tuple[List[int], List[str]]:
        """Index of model types that make a certain suggestion."""
        indices = []
        certain_suggestions = []
        for i, model_suggestions in enumerate(self.suggestions):
            for s, pr in model_suggestions.items():
                if pr == 1:
                    indices.append(i)
                    certain_suggestions.append(s)
        return indices, certain_suggestions

    @property
    def n_certain_suggestions(self) -> int:
        """Number of suggestions with probability 1.0"""
        return sum([1 for model_suggestions in self.suggestions for pr in model_suggestions.values() if pr == 1])

    def get_certain_suggestions(self) -> List:
        """Return all certain suggestions."""
        return [s for model_suggestions in self.suggestions for s, pr in model_suggestions.items() if pr == 1]

    def n_certain_unicode_suggestions(self) -> int:
        """Number of unicode suggestions with probability 1.0"""
        return sum([1 for model_suggestions in self.unicode_suggestions for pr in model_suggestions.values() if pr == 1])

    def rule_based_suggestion(self, d) -> Union[str, None]:
        """
        Cleaning heuristic to determine the best rule-based suggestion. Documentation on this can be found in
        the experiment from 2022W38.
        """
        if self.n_certain_suggestions == 0:  # No certain suggestion at all.
            return None

        if self.n_certain_suggestions == 1:  # Use the one certain suggestion.
            choice = [suggestion for model_suggestions in self.suggestions for suggestion, pr in model_suggestions.items() if pr == 1]
            if len(choice) > 1:
                raise ValueError(f"More than one certain suggestion: {choice}")
            choice = choice[0]

        elif self.n_certain_unicode_suggestions() == 1:  # Use the one certain unicode-encoded suggestion.
            # Das funktioniert in der Praxis nicht perfekt. Ich bekomme auf rayyan z.B. "1/13" als Vorschlag, obwohl ich
            # einen datestring %m/%d/%y erwarte.
            choice = [suggestion for model_suggestions in self.unicode_suggestions for suggestion, pr in model_suggestions.items() if pr == 1]
            if len(choice) > 1:
                raise ValueError(f"More than one certain suggestion: {choice}")
            choice = choice[0]

        else:  # sum up the probabilities of both encodings of all certain corrections and take the max.
            suggestion_sums = {}
            indices, suggestions = self.certain_model_type_indices_and_suggestions
            for i, s in zip(indices, suggestions):
                if i % 2 == 0:
                    corresponding_index = i + 1
                else:
                    corresponding_index = i - 1
                corresponding_score = self.suggestions[corresponding_index].get(s, 0)
                if suggestion_sums.get(s) is None:
                    suggestion_sums[s] = self.suggestions[i][s] + corresponding_score
                else:
                    suggestion_sums[s] += self.suggestions[i][s] + corresponding_score
            choice = max(suggestion_sums, key=suggestion_sums.get)

        error = d.dataframe.iloc[self.cell]
        true_correction = d.clean_dataframe.iloc[self.cell]

        # nice for debugging
        # d.debug_rules.append({'suggestions': self.get_certain_suggestions(),
        #                       'choice': choice,
        #                       'true_correction': true_correction,
        #                       'error': error})
        return choice


@dataclass
class ValueSuggestionsV2:
    """A class to hold the suggestions generated by the Value Feature-Generator."""
    cell: Tuple[int, int]
    suggestions: List[Dict[str, List[Tuple[int, int]]]]
    model_types = ["identity_remover",
                   "unicode_remover",
                   "identity_adder",
                   "unicode_adder",
                   "identity_replacer",
                   "unicode_replacer",
                   "identity_swapper",
                   "unicode_swapper"]

    @property
    def all_suggestions(self):
        return [suggestion for model in self.suggestions for suggestion in model]

    @property
    def identity_suggestions(self) -> List[Dict[str, List[Tuple[int, int]]]]:
        return [self.suggestions[0], self.suggestions[2], self.suggestions[4], self.suggestions[6]]

    @property
    def n_identity_suggestions(self) -> int:
        return sum([len(suggestions) for suggestions in self.identity_suggestions])

    @property
    def unicode_suggestions(self) -> List[Dict[str, List[Tuple[int, int]]]]:
        return [self.suggestions[1], self.suggestions[3], self.suggestions[5], self.suggestions[7]]

    @property
    def n_unicode_suggestions(self) -> int:
        return sum([len(suggestions) for suggestions in self.unicode_suggestions])

    @property
    def certain_model_type_indices_and_suggestions(self) -> Tuple[List[int], List[str]]:
        """Index of model types that make a certain suggestion."""
        indices = []
        certain_suggestions = []
        for i, model_suggestions in enumerate(self.suggestions):
            for s, pr in model_suggestions.items():
                if pr == 1:
                    indices.append(i)
                    certain_suggestions.append(s)
        return indices, certain_suggestions

    @property
    def n_certain_suggestions(self) -> int:
        """Number of suggestions with probability 1.0"""
        return sum([1 for model_suggestions in self.suggestions for pr in model_suggestions.values() if pr == 1])

    @property
    def unique_identity_suggestions(self) -> Set[str]:
        return {s for suggestion in self.identity_suggestions for s in suggestion.keys()}

    @property
    def unique_unicode_suggestions(self) -> Set[str]:
        return {s for suggestion in self.unicode_suggestions for s in suggestion.keys()}

    def get_certain_suggestions(self) -> List:
        """Return all certain suggestions."""
        return [s for model_suggestions in self.suggestions for s, pr in model_suggestions.items() if pr == 1]

    def n_certain_unicode_suggestions(self) -> int:
        """Number of unicode suggestions with probability 1.0"""
        return sum([1 for model_suggestions in self.unicode_suggestions for pr in model_suggestions.values() if pr == 1])

    def rule_based_suggestion(self, d) -> Union[str, None]:
        """
        Heuristic to reduce the list of possible suggestions to one, rule-based suggestion. This version has been
        developed following Thorsten's feedback. It is documented in 2022W40.
        """
        if self.n_identity_suggestions > 0:  # exact matches exist.
            if len(self.unique_identity_suggestions) == 1:
                return list(self.unique_identity_suggestions)[0]
            return None
        if self.n_unicode_suggestions == 1:
            # tritt nie ein -- es gibt immer mindestens eine Operation + swapper, zwischen denen man entscheidet.
            suggestions = [(c, cells) for suggestions in self.unicode_suggestions for c, cells in suggestions.items()][0]
            if len(suggestions) > 1:
                raise ValueError('Das darf nicht sein, wenn n_unicode_suggestions == 1 gilt.')
            correction, error_cells = suggestions[0]
            # TODO Check bauen, dass die Operation auf allen gelabelten Daten funktioniert.
            return correction
        elif self.n_unicode_suggestions > 1:
            if len(self.unique_unicode_suggestions) == 1:
                return list(self.unique_unicode_suggestions)[0]

            # Was machen wir, wenn der selbe Reinigungsvorschlag aus unterschiedlichen Regeln gemacht wird?
            distances_to_errors = [(s, lev_to_original_error(self.cell, cells, d.dataframe)) for s in self.unicode_suggestions for cells in s.values()]
            mean_distances = [(s, np.mean(distances)) for s, distances in distances_to_errors]
            sorted_mean_distances = sorted(mean_distances, key=lambda x: x[1])
            shortest_distance = sorted_mean_distances[0][1]

            shortest_suggestions = [t[0] for t in sorted_mean_distances if t[1] == shortest_distance]
            if len(shortest_suggestions) == 1:
                return list(sorted_mean_distances[0][0].keys())[0]
            else:
                distances_to_corrections = [(s, lev_to_original_corrections(s, cells, d.labeled_cells)) for sug in shortest_suggestions for s, cells in sug.items()]
                mean_distances = [(c, np.mean(distances)) for c, distances in distances_to_corrections]
                sorted_mean_distances = sorted(mean_distances, key=lambda x: x[1])
                shortest_distance = sorted_mean_distances[0][1]

                shortest_suggestions = [t[0] for t in sorted_mean_distances if t[1] == shortest_distance]
                if len(shortest_suggestions) == 1:
                    return sorted_mean_distances[0][0]
                return sorted_mean_distances[0][0]  # random choice
        return None
